from parse import *
import pygit2
from github import Github
import subprocess
import sys
import argparse


def is_npm_repo(r):
    package = False
    package_lock = False
    if (r.language == "TypeScript") or (r.language == "JavaScript"):
        for file in r.get_contents(""):
            if file.path == "package.json":
                package = True
            if file.path == "package-lock.json":
                package_lock = True
    return package and package_lock


def no_open_pulls_from_me(r):
    for pull in r.get_pulls():
        if pull.user == me:
            return False
    return True


def fix_issues(r_path):
    try:
        fix_output = subprocess.check_output(["npm", "audit", "fix"], cwd=r_path, shell=True)
    except subprocess.CalledProcessError:
        return 0
    try:
        fix_output_string = fix_output.decode("utf-8")
        parsed = search("fixed {:d} of ", fix_output_string)

        return parsed.fixed[0]
    except ValueError:
        return 0


def run_built_in_commands(r_path):
    commands = [["npm", "i"], ["npm", "all"], ["npm", "run", "build", "--if-present"],
                ["npm", "run", "lint", "--if-present"], ["npm", "run", "lint-fix", "--if-present"],
                ["npm", "run", "format", "--if-present"], ["npm", "run", "format-fix", "--if-present"],
                ["npm", "run", "package", "--if-present"]]
    for command in commands:
        try:
            subprocess.check_output(command, shell=True, cwd=r_path)
        except subprocess.CalledProcessError:
            pass


def pr_title(num_fixed):
    v = "vulnerability" if num_fixed == 1 else "vulnerabilities"
    return f"Updated packages to fix {num_fixed} {v}"


def pr_body(num_fixed):
    v = "vulnerability" if num_fixed == 1 else "vulnerabilities"
    w = "was" if num_fixed == 1 else "were"
    return f"I ran `npm audit fix` to find and update out-of-date packages with known vulnerabilities. {num_fixed} {v}" \
           f" {w} found and patched."


def get_input(args=None):
    if args is None:
        args = sys.argv[1:]
    parser = argparse.ArgumentParser(description="Repo Audit")
    parser.add_argument("-p", "--pat", required=True, help="Your GitHub Personal Access Token")
    parser.add_argument("-t", "--team", help="Audit all repos belonging to the provided team")
    parser.add_argument("-o", "--organization", type=int,
                        help="Audit all repos belonging to the provided organization")
    parser.add_argument("-n", "--npm", dest='npm', action='store_true',
                        help="Attempt to run common npm  commands (build, lint, pack)")
    return parser.parse_args(args)


def get_source(i):
    if i.team is not None:
        for team in g.get_user().get_teams():
            if team.name.lower() == i.team.lower():
                return team
        raise ValueError("Invalid Team Name")
    elif i.organization is not None:
        return g.get_organization(i.organization)
    else:
        return g.get_user()


i = get_input()
g = Github(i.pat)
source = get_source(i)
me = g.get_user()

for repo in source.get_repos():
    if no_open_pulls_from_me(repo) and is_npm_repo(repo):
        path = f"repos/{repo.name}"
        print(f"-----{repo.full_name}-----")
        print(f"Cloning repo to {path}")
        try:
            clone = pygit2.clone_repository(repo.git_url, path)
        except:
            print("Already cloned - Skipping")
            continue
        print("Running npm audit fix")
        fixed = fix_issues(path)
        if fixed == 0:
            print("No issues fixed automatically")
        else:
            print("Running commands from package.json")
            run_built_in_commands(path)
            print(f"{fixed} issues fixed automatically")
            title = pr_title(fixed)
            body = pr_body(fixed)
            print(f"PR Title: {title}\nPR Body: {body}")
